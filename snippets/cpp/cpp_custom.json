{
  "Current Date Time": {
    "prefix": "datetime",
    "body": [
      "#include <chrono>",
      "#include <format>",
      "#include <string>",
      "",
      "std::string $0GetCurrentDateTime() noexcept{",
      " const auto now = std::chrono::system_clock::now();",
      " const auto time_point = std::chrono::floor<std::chrono::seconds>(now);",
      "",
      " return std::format(\"{:%Y-%m-%d %H:%M:%S}\", time_point);",
      "}"
    ],
    "description": "Function to get current date and time in YYYY-MM-DD HH:MM:SS format"
  },
  "SizeofAll": {
    "prefix": "sizeofall",
    "body": [
      " #include <array>",
      " #include <iostream>",
      " #include <memory>",
      " #include <optional>",
      " #include <string>",
      " #include <string_view>",
      " #include <vector>",
      " ",
      " // This is a C++23-compatible snippet, although the core functionality",
      " // of `sizeof` has been a part of C++ for a long time.",
      " ",
      " // Define a simple struct to demonstrate the size of a user-defined type.",
      " // The size of this struct will be affected by memory alignment.",
      " struct MyStruct {",
      " int id;",
      " double value;",
      " char flag;",
      " };",
      " ",
      " struct alignas(8) MyStructAligned {",
      " double value;",
      " int id;",
      " char flag;",
      " };",
      " ",
      " int main() {",
      " // Print the sizes of fundamental data types.",
      " std::cout << \"Size of fundamental data types:\\n\\n\";",
      " ",
      " std::cout << \"Size of bool: \" << sizeof(bool) << \" byte(s)\\n\";",
      " std::cout << \"Size of char: \" << sizeof(char) << \" byte(s)\\n\";",
      " std::cout << \"Size of wchar_t: \" << sizeof(wchar_t) << \" byte(s)\\n\";",
      " std::cout << \"Size of char8_t: \" << sizeof(char8_t)",
      " << \" byte(s) (introduced in C++20)\\n\";",
      " std::cout << \"Size of short: \" << sizeof(short) << \" byte(s)\\n\";",
      " std::cout << \"Size of int: \" << sizeof(int) << \" byte(s)\\n\";",
      " std::cout << \"Size of long: \" << sizeof(long) << \" byte(s)\\n\";",
      " std::cout << \"Size of long long: \" << sizeof(long long) << \" byte(s)\\n\";",
      " std::cout << \"Size of float: \" << sizeof(float) << \" byte(s)\\n\";",
      " std::cout << \"Size of double: \" << sizeof(double) << \" byte(s)\\n\";",
      " std::cout << \"Size of long double: \" << sizeof(long double) << \" byte(s)\\n\";",
      " std::cout << \"Size of void*: \" << sizeof(void*)",
      " << \" byte(s) (pointer size)\\n\";",
      " std::cout << \"\\n\";",
      " ",
      " // Print the sizes of standard library types and our custom struct.",
      " std::cout << \"Size of other types:\\n\\n\";",
      " ",
      " // Note that the sizes of std::string and std::vector are the",
      " // sizes of their internal control structures, not the size of the",
      " // data they hold.",
      " std::cout << \"Size of std::string: \" << sizeof(std::string) << \" byte(s)\\n\";",
      " std::cout << \"Size of std::string_view: \" << sizeof(std::string_view)",
      " << \" byte(s)\\n\";",
      " std::cout << \"Size of std::vector<int>: \" << sizeof(std::vector<int>)",
      " << \" byte(s)\\n\";",
      " std::cout << \"Size of std::array<int, 5>: \" << sizeof(std::array<int, 5>)",
      " << \" byte(s)\\n\";",
      " std::cout << \"Size of std::optional<int>: \" << sizeof(std::optional<int>)",
      " << \" byte(s)\\n\";",
      " std::cout << \"Size of std::optional<float>: \"",
      " << sizeof(std::optional<float>) << \" byte(s)\\n\";",
      " ",
      " // The size of smart pointers is the size of the pointer object itself,",
      " // not the size of the object they manage on the heap.",
      " std::cout << \"Size of std::unique_ptr<int>: \"",
      " << sizeof(std::unique_ptr<int>) << \" byte(s)\\n\";",
      " std::cout << \"Size of std::shared_ptr<int>: \"",
      " << sizeof(std::shared_ptr<int>) << \" byte(s)\\n\";",
      " std::cout << \"Size of std::weak_ptr<int>: \" << sizeof(std::weak_ptr<int>)",
      " << \" byte(s)\\n\";",
      " ",
      " std::cout << \"Size of MyStruct: \" << sizeof(MyStruct) << \" byte(s)\\n\";",
      " std::cout << \"Align of MyStruct: \" << alignof(MyStruct) << \" byte(s)\\n\";",
      " ",
      " std::cout << \"Size of MyStructAligned: \" << sizeof(MyStructAligned)",
      " << \" byte(s)\\n\";",
      " std::cout << \"Align of MyStructAligned: \" << alignof(MyStructAligned)",
      " << \" byte(s)\\n\";",
      " return 0;",
      " }"
    ],
    "description": "Print Size of ALL"
  },
  "High Res Timer": {
    "prefix": "highrestimer",
    "body": [
      " #include <iostream>",
      " #include <string>",
      " #include <chrono>",
      " class HighResTimer final {",
      " public:",
      " explicit constexpr HighResTimer() noexcept { Reset(); }",
      " ",
      " void Reset() noexcept { start_time_ = std::chrono::high_resolution_clock::now(); }",
      " ",
      " void StopAndPrint(const std::string& message = \"Execution time\") noexcept {",
      " const auto end_time = std::chrono::high_resolution_clock::now();",
      " const auto duration_ns = std::chrono::duration_cast<std::chrono::nanoseconds>(end_time - start_time_);",
      " const float duration_ms = static_cast<float>(duration_ns.count()) * 0.000001F;",
      " stop_watch_ += duration_ms;",
      " std::cout << message << \": \" << duration_ms << \" milliseconds.\" << std::endl;",
      " }",
      " ",
      " void GetTrackedTime() noexcept {",
      " std::cout << \" So far GetTrackedTime << \" << stop_watch_ << std::endl;",
      " stop_watch_ = 0.0F;",
      " }",
      " ",
      " private:",
      " std::chrono::time_point<std::chrono::high_resolution_clock> start_time_;",
      " float stop_watch_{0.0F};",
      " };",
      " ",
      " // // Example Usage:",
      " // // Code to measure...",
      " HighResTimer timer;",
      " timer.StopAndPrint();",
      " timer.GetTrackedTime();"
    ],
    "description": "high resolution timer class to measure execution time"
  },
  "Cuda High Res Timer": {
    "prefix": "cudahighrestimer",
    "body": [
      "#include <cuda_runtime.h>",
      "",
      "class CudaHighResTimer final {",
      " public:",
      "  explicit CudaHighResTimer() noexcept {",
      "    cudaEventCreate(&start_event_);",
      "    cudaEventCreate(&stop_event_);",
      "    Reset();",
      "  }",
      "",
      "  ~CudaHighResTimer() noexcept {",
      "    cudaEventDestroy(start_event_);",
      "    cudaEventDestroy(stop_event_);",
      "  }",
      "",
      "  void Reset() noexcept { cudaEventRecord(start_event_, 0); }",
      "",
      "  void StopAndPrint(const std::string& message = \"Execution time\") noexcept {",
      "    cudaEventRecord(stop_event_, 0);",
      "    cudaEventSynchronize(stop_event_);",
      "",
      "    float duration_ms;",
      "    cudaEventElapsedTime(&duration_ms, start_event_, stop_event_);",
      "",
      "    printf(\"\\t\\t%s: %.5f milliseconds. \\n \", message.c_str(), duration_ms);",
      "  }",
      "",
      " private:",
      "  cudaEvent_t start_event_;",
      "  cudaEvent_t stop_event_;",
      "};"
    ],
    "description": "high resolution timer class to measure execution time"
  },
  "Your Custom Snippet": {
    "prefix": "customsnippet",
    "body": [
      "// Add your snippet content here",
      "$0"
    ],
    "description": "Description of your custom snippet"
  }
}
